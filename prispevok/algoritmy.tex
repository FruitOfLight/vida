\section{Vybrané distribuované algoritmy}
TODO citacie a odkazy

Aby sme lepšie pochopili, čím sa naša vizualizácia zaoberá, ujasníme si najskôr pojmy a problematiku.

V našom ponímaní distribuovaných algoritmov, máme nasledovný výpočtový model.
Uvažujme niekoľko počítačov, z ktorých sú niektoré dvojice spojené obojsmernou komunikačnou linkou.
Inak povedané, počítače tvoria neorientovaný graf. Nayše kvôli povahe samotných algoritmov zväčša vyžadujeme,
aby bol graf súvislý.

Do každého z týchto počítačov sa nahrá ten istý program a všetky sa naraz spustia. Programy si môžu
interne čokoľvek počítať a zároveň dokážu poslať správu po ľubovoľnej linke. O správach na linkách
vieme len to, že v konečnom čase dorazia na druhý koniec, a keď jeden počítač pošle po jednej linke
viac správ, tak dorazia v tom istom poradí, v akom boli poslané. O poradí doručenia správ na rôznych
linkách nevieme povedať nič a každá správa sa môže doručovať ľubovoľne dlho. Nemáme teda žiadne garancie, či
správa dorazí do desať minút a kľudne sa môže stať, že niektoré správy prejdú tísícky hrán, zatiaľ čo
iné len jednu.

Dôležitý parameter pri návrhu algoritmu pracujúcom v tomto modeli, je počet správ, ktoré sa dokopy
pošlú počase jeho behu. Pochopiteľne sa snažíme aby sa v najhoršom prípade poslalo čo najmenej
správ.

Momentálne sú v aplikácii naimplementované vizualizácie troch algoritmov.

\subsection{Broadcast}

Jednym z jednodnuchších problémov, ktoré treba v distribuovaných algoritmoch riešiť je, ako 
oznámiť nejakú správu všetkým počítačom (nielen susedom). Keď všetky počítače naštartujú, 
jeden z nich má nejakú informáciu a ostatné by sa ju tiež radi dozvedeli.

Problém sa rieši pomerne priamočiaro, prvý počítač pošle správu všetkým susedom, a každý
počítač, ktorý dostane správu, najprv skontroluje, či už niekedy správu posielal. 
Ak ju ešte neposielal, pošle ju všetkým susedom s výjnimkov toho, od ktorého správa prišla.

Takto po každej linke prejde najviac jedna správa, čím dosiahneme optimálny výsledok $O(m)$ správ,
kde $m$ je počet liniek.

\subsection{Voľba šéfa na $n$-vrcholovom úplnom grafe s počtom správ $O(n\log n)$}

Ako názov naznačuje, v tejto sekcii máme $n$ počítačov a všetky dvojice počítačov sú spojené linkou. 
Navyše, má každý počítač svoj jednoznačný identifikátor (ľubovoľné celé číslo, nazvime ho $id$), bez identifikátorov
by sa totiž problém nedal riešiť, kvôli symetrii.

Počítače na začiatku poznajú len svoje $id$ a vidia $n-1$ portov očíslovaných číslami $1$ až $n-1$ v
ľubovoľnom poradí (nevedia teda za akým portom je aký počítač). Následne sú programy spustené a môžu začať posielať správy.
Chceme nájsť taký algoritmus, ktorý pre ľubovoľné identifikátory, časovanie správ a poradie
portov, vždy skončí tak, že práve jeden počítač bude vedieť o sebe, že je šéf a ostatné budú vedieť, že nie sú šefovia.

Dá sa dokázať, že každý takýto algoritmus musí poslať aspoň $O(n\log n)$ správ a my si povieme o
jednom z takých, ktoré to dokážu.

Tématika algoritmu je umiestnená do stredoveku, pretože počítače medzi sebou obrazne bojujú a snažia
sa stať panovníkom čo najväčšiaho počtu iných počítačov -- tí sa im stanú vazalmi. 
Počítače môžu vyzvať iný počítač na súboj, a ak vyzívateľ vyhrá, porazený sa stáva jeho vazalom.

Algoritmus teda funguje tak, že na to, aby sa stal počítač šéfom, musí mať $n-1$ vazalov (teda musí
poraziť všetky ostatné počítače) a sám nesmie byť nikomu vazalom. Každý počítač je vazalom najviac 
jedného počítača. Z tohto vyplýva, že šéf bude najviac jeden. Navyše si označme $level =$  počet vazalov.

Na začiatku sa chce každý počítač stať šéfom a teda snaží sa získať nejakých vazalov. To robí tak,
že pošle nejakému susedovi správu \verb!"Mám level x, id y a chcem ťa zajať."! 

Ak sused už nie je vazalom niekoho iného, lexikograficky porovná svoju dvojicu $(level, id)$ s dvojicou so správy. 
Ak je jeho dvojica väčšia, správu ignoruje a teda pôvodný počítač nikdy nezajme všetkých, čím
zahynie jeho šanca stať sa šéfom. 
Inak mu odpovie \verb!"Som tvojim vazalom"!. Pôvodný počítač si zvýši $level$ a snaží sa zajať niekoho
ďalšieho. Takto pokračuje, až kým sa nestane, že mu niekto neodpovie, alebo sa nestane šéfom.

Druhá možnosť je, že sused už je vazalom nejakého počítača, vtedy požiada o pomoc svojho panovníka.
Podľa $levelu$ a $id$ panovníka sa rovnakým spôsobom rozhodne, či sa správa ignoruje, alebo 
sa sused stane vazalom vyzívateľa a panovník sa stane porazeným (síce nebude nikoho vazalom, kým sa
ho niekto priamo nepokúsi zajať, ale už nebude zajímať ďalších vazalov).

Dôkaz, že sa pošle najviac $O(n\log n)$ správ sa dá skonštruovať jednoducho, keď si všimneme, 
že počítačom s $levelom$ $i$ može byť najviac $n/i$.

Ak ste náhodou fungovanie algoritmu z tohoto popisu nepochopili, tak je to dôvod na to, aby ste si vyskúšali našu
čarovnú aplikáciu. Na to je predsa určená.

\subsection{Traverzal}

Traverzovací algoritmus, sa zaoberá prieskumom grafu so špeciálnym obmedzením na posielanie správ.
Namiesto správ existuje jeden token. Počítač, ktorý má v danej chívli token, ho môže poslať ľubovoľnému
susedovi, čím token stratí. Žiadne iné správy sa posielať nemôžu. 

TODO pozriet ako je to vlastne definovane.
V týchto algoritmoch sa zaujímame o to, koľko správ musíme poslať aby sme navštívili $x$ vrcholov.

Takéto traverzovacie algoritmy sa majú aj tú výhodu, že ľahko usledujeme celkový počet odoslaných
správ čo vieme využiť pri návrhu zložitejších algoritmov (napríklad KKM).

My sme naimplementovali jednoduchý traverzovací algoritmus pre všeobecné grafy, fungujúci ako 
prehľadávanie do hĺbky. Pre ilustráciu sa snaží jeden vrchol zistiť súčet identifikátorov ostatných
vrcholov (v tokene môžu byť zabalené aj nejaké informácie, v tomto prípade doterajší súčet).






